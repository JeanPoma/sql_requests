-- ============================================
-- EXERCICE: TOP 3 des jeux par annÃ©e (Window Functions)
-- NIVEAU: ðŸŸ¡ IntermÃ©diaire
-- CONCEPTS: Window Functions, RANK/DENSE_RANK, PARTITION BY
--
-- ðŸ“š Ressources SQLZoo recommandÃ©es :
-- - Tutorial 8+ : https://sqlzoo.net/wiki/Window_functions
--
-- ðŸŽ¯ OBJECTIF PÃ‰DAGOGIQUE:
-- Introduction aux fonctions de fenÃªtre (window functions) pour calculer
-- des rangs Ã  l'intÃ©rieur de groupes (ici: par annÃ©e).
--
-- ðŸ’¡ RAPPEL DE SYNTAXE:
-- SELECT colonnes,
--        DENSE_RANK() OVER (PARTITION BY groupe ORDER BY critere DESC) AS rnk
-- FROM table
-- WHERE filtres
--
-- DIFFÃ‰RENCE RANK vs DENSE_RANK:
-- - RANK: 1, 2, 2, 4 (saute le rang 3 en cas d'ex-aequo)
-- - DENSE_RANK: 1, 2, 2, 3 (ne saute jamais de rang)
--
-- ============================================
-- CONSIGNE:
-- Pour chaque annÃ©e, retournez le TOP 3 des jeux par Metacritic.
--
-- Utiliser une fonction de fenÃªtre (DENSE_RANK ou RANK):
-- - PartitionnÃ©e par year (chaque annÃ©e a son propre classement)
-- - OrdonnÃ©e par metacritic DESC, puis ratings_count DESC
--
-- Colonnes attendues: year, name, metacritic, rnk
--
-- Filtres:
-- - year IS NOT NULL
-- - metacritic IS NOT NULL
-- - Garder uniquement rnk <= 3 (TOP 3)
--
-- Ordre final: year DESC, rnk ASC
--
-- ðŸ’¡ ASTUCE:
-- Vous devrez utiliser une sous-requÃªte ou une CTE car on ne peut pas
-- filtrer directement sur le rÃ©sultat d'une window function dans WHERE.
--
-- Exemple de structure:
-- WITH ranked AS (
--   SELECT ..., DENSE_RANK() OVER (...) AS rnk
--   FROM ...
-- )
-- SELECT * FROM ranked WHERE rnk <= 3;
--
-- ðŸ’¡ POURQUOI C'EST UTILE ?
-- Les window functions permettent de faire des classements Ã  l'intÃ©rieur
-- de groupes sans perdre les dÃ©tails individuels (contrairement Ã  GROUP BY).
-- ============================================
